{"version":3,"sources":["../src/spriteUtilities.js"],"names":[],"mappings":"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","file":"spriteUtilities.js","sourcesContent":["class SpriteUtilities{\n  constructor(renderingEngine = PIXI) {\n    if (renderingEngine === undefined) throw new Error(\"Please supply a reference to PIXI in the SpriteUtilities constructor before using spriteUtilities.js\"); \n\n    //Find out which rendering engine is being used (the default is Pixi)\n    this.renderer = \"\";\n\n    //If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (renderingEngine.ParticleContainer && renderingEngine.Sprite) {\n      this.renderer = \"pixi\";\n      this.Container = renderingEngine.Container;\n      this.ParticleContainer = renderingEngine.ParticleContainer;\n      this.TextureCache = renderingEngine.utils.TextureCache;\n      this.Texture = renderingEngine.Texture;\n      this.Rectangle = renderingEngine.Rectangle;\n      this.MovieClip = renderingEngine.extras.MovieClip;\n      this.BitmapText = renderingEngine.extras.BitmapText;\n      this.Sprite = renderingEngine.Sprite;\n      this.TilingSprite = renderingEngine.extras.TilingSprite;\n      this.Graphics = renderingEngine.Graphics;\n      this.Text = renderingEngine.Text;\n    }\n  }\n\n  sprite(source, x = 0, y = 0, tiling = false, width, height) {\n\n    let o, texture;\n\n    //Create a sprite if the `source` is a string \n    if (typeof source === \"string\") {\n\n      //Access the texture in the cache if it's there\n      if (this.TextureCache[source]) {\n        texture = this.TextureCache[source];\n      }\n\n      //If it's not is the cache, load it from the source file\n      else {\n        texture = this.Texture.fromImage(source);\n      }\n\n      //If the texture was created, make the o\n      if (texture) {\n\n        //If `tiling` is `false`, make a regular `Sprite`\n        if (!tiling) {\n          o = new this.Sprite(texture);\n        }\n\n        //If `tiling` is `true` make a `TilingSprite`\n        else {\n          o = new this.TilingSprite(texture, width, height);\n        }\n      }\n      //But if the source still can't be found, alert the user\n      else {\n        console.log(`${source} cannot be found`);\n      }\n    }\n\n    //Create a o if the `source` is a texture\n    else if (source instanceof this.Texture) {\n      if (!tiling) {\n        o = new this.Sprite(source);\n      } else {\n        o = new this.TilingSprite(source, width, height);\n      }\n    }\n\n    //Create a `MovieClip` o if the `source` is an array\n    else if (source instanceof Array) {\n\n      //Is it an array of frame ids or textures?\n      if (typeof source[0] === \"string\") {\n\n        //They're strings, but are they pre-existing texture or\n        //paths to image files?\n        //Check to see if the first element matches a texture in the\n        //cache\n        if (this.TextureCache[source[0]]) {\n\n          //It does, so it's an array of frame ids\n          o = this.MovieClip.fromFrames(source);\n        } else {\n\n          //It's not already in the cache, so let's load it\n          o = this.MovieClip.fromImages(source);\n        }\n      }\n\n      //If the `source` isn't an array of strings, check whether\n      //it's an array of textures\n      else if (source[0] instanceof this.Texture) {\n\n        //Yes, it's an array of textures. \n        //Use them to make a MovieClip o \n        o = new this.MovieClip(source);\n      }\n    }\n\n    //If the sprite was successfully created, intialize it\n    if (o) {\n\n      //Position the sprite\n      o.x = x;\n      o.y = y;\n\n      //Set optional width and height\n      if (width) o.width = width;\n      if (height) o.height = height;\n\n      //If the sprite is a MovieClip, add a state player so that\n      //it's easier to control\n      if (o instanceof this.MovieClip) this.addStatePlayer(o);\n\n      //Assign the sprite\n      return o;\n    }\n  }\n\n  addStatePlayer(sprite) {\n\n    let frameCounter = 0,\n      numberOfFrames = 0,\n      startFrame = 0,\n      endFrame = 0,\n      timerInterval = undefined;\n\n    //The `show` function (to display static states)\n    function show(frameNumber) {\n\n      //Reset any possible previous animations\n      reset();\n\n      //Find the new state on the sprite\n      sprite.gotoAndStop(frameNumber);\n    }\n\n    //The `stop` function stops the animation at the current frame\n    function stopAnimation() {\n      reset();\n      sprite.gotoAndStop(sprite.currentFrame);\n    }\n\n    //The `playSequence` function, to play a sequence of frames\n    function playAnimation(sequenceArray) {\n\n      //Reset any possible previous animations\n      reset();\n\n      //Figure out how many frames there are in the range\n      if (!sequenceArray) {\n        startFrame = 0;\n        endFrame = sprite.totalFrames - 1;\n      } else {\n        startFrame = sequenceArray[0];\n        endFrame = sequenceArray[1];\n      }\n\n      //Calculate the number of frames\n      numberOfFrames = endFrame - startFrame;\n\n      //Compensate for two edge cases:\n      //1. If the `startFrame` happens to be `0`\n      /*\n      if (startFrame === 0) {\n        numberOfFrames += 1;\n        frameCounter += 1;\n      }\n      */\n\n      //2. If only a two-frame sequence was provided\n      /*\n      if(numberOfFrames === 1) {\n        numberOfFrames = 2;\n        frameCounter += 1;\n      }  \n      */\n\n      //Calculate the frame rate. Set the default fps to 12\n      if (!sprite.fps) sprite.fps = 12;\n      let frameRate = 1000 / sprite.fps;\n\n      //Set the sprite to the starting frame\n      sprite.gotoAndStop(startFrame);\n\n      //Set the `frameCounter` to the first frame \n      frameCounter = 1;\n\n      //If the state isn't already `playing`, start it\n      if (!sprite.animating) {\n        timerInterval = setInterval(advanceFrame.bind(this), frameRate);\n        sprite.animating = true;\n      }\n    }\n\n    //`advanceFrame` is called by `setInterval` to display the next frame \n    //in the sequence based on the `frameRate`. When the frame sequence \n    //reaches the end, it will either stop or loop\n    function advanceFrame() {\n\n      //Advance the frame if `frameCounter` is less than \n      //the state's total frames\n      if (frameCounter < numberOfFrames + 1) {\n\n        //Advance the frame\n        sprite.gotoAndStop(sprite.currentFrame + 1);\n\n        //Update the frame counter\n        frameCounter += 1;\n\n        //If we've reached the last frame and `loop`\n        //is `true`, then start from the first frame again\n      } else {\n        if (sprite.loop) {\n          sprite.gotoAndStop(startFrame);\n          frameCounter = 1;\n        }\n      }\n    }\n\n    function reset() {\n\n      //Reset `sprite.playing` to `false`, set the `frameCounter` to 0, //and clear the `timerInterval`\n      if (timerInterval !== undefined && sprite.animating === true) {\n        sprite.animating = false;\n        frameCounter = 0;\n        startFrame = 0;\n        endFrame = 0;\n        numberOfFrames = 0;\n        clearInterval(timerInterval);\n      }\n    }\n\n    //Add the `show`, `play`, `stop`, and `playSequence` methods to the sprite\n    sprite.show = show;\n    sprite.stopAnimation = stopAnimation;\n    sprite.playAnimation = playAnimation;\n  }\n\n  filmstrip(\n    texture,\n    frameWidth,\n    frameHeight,\n    spacing = 0\n  ) {\n\n    //An array to store the x/y positions of the frames\n    let positions = [];\n\n    //Find the width and height of the texture\n    let textureWidth = this.TextureCache[texture].width,\n      textureHeight = this.TextureCache[texture].height;\n\n    //Find out how many columns and rows there are\n    let columns = textureWidth / frameWidth,\n      rows = textureHeight / frameHeight;\n\n    //Find the total number of frames\n    let numberOfFrames = columns * rows;\n\n    for (let i = 0; i < numberOfFrames; i++) {\n\n      //Find the correct row and column for each frame\n      //and figure out its x and y position\n      let x = (i % columns) * frameWidth,\n        y = Math.floor(i / columns) * frameHeight;\n\n      //Compensate for any optional spacing (padding) around the tiles if\n      //there is any. This bit of code accumlates the spacing offsets from the \n      //left side of the tileset and adds them to the current tile's position \n      if (spacing > 0) {\n        x += spacing + (spacing * i % columns);\n        y += spacing + (spacing * Math.floor(i / columns));\n      }\n\n      //Add the x and y value of each frame to the `positions` array\n      positions.push([x, y]);\n    }\n    console.log(positions)\n\n    //Return the frames\n    return this.frames(texture, positions, frameWidth, frameHeight);\n  }\n\n  //Make a texture from a frame in another texture or image\n  frame(source, x, y, width, height) {\n\n    let texture, imageFrame;\n\n    //If the source is a string, it's either a texture in the\n    //cache or an image file\n    if (typeof source === \"string\") {\n      if (this.TextureCache[source]) {\n        texture = new this.Texture(this.TextureCache[source]);\n      }\n    }\n\n    //If the `source` is a texture,  use it\n    else if (source instanceof this.Texture) {\n      texture = new this.Texture(source);\n    }\n    if (!texture) {\n      console.log(`Please load the ${source} texture into the cache.`);\n    } else {\n\n      //Make a rectangle the size of the sub-image\n      imageFrame = new this.Rectangle(x, y, width, height);\n      texture.frame = imageFrame;\n      return texture;\n    }\n  }\n\n  //Make an array of textures from a 2D array of frame x and y coordinates in\n  //texture\n  frames(source, coordinates, frameWidth, frameHeight) {\n\n    let baseTexture, textures;\n\n    //If the source is a string, it's either a texture in the\n    //cache or an image file\n    if (typeof source === \"string\") {\n      if (this.TextureCache[source]) {\n        baseTexture = new this.Texture(this.TextureCache[source]);\n      }\n    }\n    //If the `source` is a texture,  use it\n    else if (source instanceof this.Texture) {\n      baseTexture = new this.Texture(source);\n    }\n    if (!baseTexture) {\n      console.log(`Please load the ${source} texture into the cache.`);\n    } else {\n      let textures = coordinates.map((position) => {\n        let x = position[0],\n          y = position[1];\n        let imageFrame = new this.Rectangle(x, y, frameWidth, frameHeight);\n        let frameTexture = new this.Texture(baseTexture);\n        frameTexture.frame = imageFrame;\n        return frameTexture\n      });\n      return textures;\n    }\n  }\n\n  frameSeries(startNumber = 0, endNumber = 1, baseName = \"\", extension = \"\") {\n\n    //Create an array to store the frame names\n    let frames = [];\n\n    for (let i = startNumber; i < endNumber + 1; i++) {\n      let frame = this.TextureCache[`${baseName + i + extension}`];\n      frames.push(frame);\n    }\n    return frames;\n  }\n\n  /* Text creation */\n\n  //The`text` method is a quick way to create a Pixi Text sprite\n  text(content = \"message\", font = \"16px sans\", fillStyle = \"red\", x = 0, y = 0) {\n\n    //Create a Pixi Sprite object\n    let message = new this.Text(content, {font: font, fill: fillStyle});\n    message.x = x;\n    message.y = y;\n\n    //Add a `_text` property with a getter/setter\n    message._content = content;\n    Object.defineProperty(message, \"content\", {\n      get() {\n        return this._content;\n      },\n      set(value) {\n        this._content = value;\n        this.text = value;\n      },\n      enumerable: true, configurable: true\n    });\n\n    //Return the text object\n    return message;\n  }\n\n  //The`bitmapText` method lets you create bitmap text\n  bitmapText(content = \"message\", font, align, tint, x = 0, y = 0) {\n\n    //Create a Pixi Sprite object\n    let message = new this.BitmapText(content, {font: font, align: align, tint: tint});\n    message.x = x;\n    message.y = y;\n\n    //Add a `_text` property with a getter/setter\n    message._content = content;\n    Object.defineProperty(message, \"content\", {\n      get() {\n        return this._content;\n      },\n      set(value) {\n        this._content = value;\n        this.text = value;\n      },\n      enumerable: true, configurable: true\n    });\n\n    //Return the text object\n    return message;\n  }\n\n  /* Shapes and lines */\n\n  //Rectangle\n  rectangle(\n      width = 32, \n      height = 32,  \n      fillStyle = 0xFF3300, \n      strokeStyle = 0x0033CC, \n      lineWidth = 0,\n      x = 0, \n      y = 0 \n    ){\n\n    //Draw the rectangle\n    let rectangle = new this.Graphics();\n    rectangle.beginFill(fillStyle);\n    if (lineWidth > 0) {\n      rectangle.lineStyle(lineWidth, strokeStyle, 1);\n    }\n    rectangle.drawRect(0, 0, width, height);\n    rectangle.endFill();\n\n    //Generate a texture from the rectangle\n    let texture = rectangle.generateTexture();\n\n    //Use the texture to create a sprite\n    let sprite = new this.Sprite(texture);\n\n    //Position the sprite\n    sprite.x = x;\n    sprite.y = y;\n\n    //Return the sprite\n    return sprite;\n  }\n\n  //Circle\n  circle(\n      diameter = 32, \n      fillStyle = 0xFF3300, \n      strokeStyle = 0x0033CC, \n      lineWidth = 0,\n      x = 0, \n      y = 0 \n    ){\n\n    //Draw the circle\n    let circle = new this.Graphics();\n    circle.beginFill(fillStyle);\n    if (lineWidth > 0) {\n      circle.lineStyle(lineWidth, strokeStyle, 1);\n    }\n    circle.drawCircle(0, 0, diameter / 2);\n    circle.endFill();\n\n    //Generate a texture from the rectangle\n    let texture = circle.generateTexture();\n\n    //Use the texture to create a sprite\n    let sprite = new this.Sprite(texture);\n\n    //Position the sprite\n    sprite.x = x;\n    sprite.y = y;\n\n    //Return the sprite\n    return sprite;\n  }\n\n  //Line\n  line(\n      strokeStyle = 0x000000, \n      lineWidth = 1, \n      ax = 0, \n      ay = 0, \n      bx = 32, \n      by = 32\n    ){\n\n    //Create the line object\n    let line = new this.Graphics();\n\n    //Add properties\n    line._ax = ax;\n    line._ay = ay;\n    line._bx = bx;\n    line._by = by;\n    line.strokeStyle = strokeStyle;\n    line.lineWidth = lineWidth;\n\n    //A helper function that draws the line\n    line.draw = () => {\n      line.clear();\n      line.lineStyle(lineWidth, strokeStyle, 1);\n      line.moveTo(line._ax, line._ay);\n      line.lineTo(line._bx, line._by);\n    };\n    line.draw();\n\n    //Define getters and setters that redefine the line's start and \n    //end points and re-draws it if they change\n    Object.defineProperties(line, {\n      \"ax\": {\n        get() {\n          return this._ax;\n        },\n        set(value) {\n          this._ax = value;\n          this.draw();\n        }, \n        enumerable: true, configurable: true\n      },\n      \"ay\": {\n        get() {\n          return this._ay;\n        },\n        set(value) {\n          this._ay = value;\n          this.draw();\n        }, \n        enumerable: true, configurable: true\n      },\n      \"bx\": {\n        get() {\n          return this._bx;\n        },\n        set(value) {\n          this._bx = value;\n          this.draw();\n        }, \n        enumerable: true, configurable: true\n      },\n      \"by\": {\n        get() {\n          return this._by;\n        },\n        set(value) {\n          this._by = value;\n          this.draw();\n        }, \n        enumerable: true, configurable: true\n      },\n    });\n\n    //Return the line\n    return line;\n  }\n\n  /* Compound sprites */\n\n  //Use `grid` to create a grid of sprites\n  grid(\n    columns = 0, rows = 0, cellWidth = 32, cellHeight = 32,\n    centerCell = false, xOffset = 0, yOffset = 0,\n    makeSprite = undefined,\n    extra = undefined\n  ){\n\n    //Create an empty group called `container`. This `container`\n    //group is what the function returns back to the main program.\n    //All the sprites in the grid cells will be added\n    //as children to this container\n    let container = new this.Container();\n\n    //The `create` method plots the grid\n\n    let createGrid = () => {\n\n      //Figure out the number of cells in the grid\n      let length = columns * rows;\n\n      //Create a sprite for each cell\n      for(let i = 0; i < length; i++) {\n\n        //Figure out the sprite's x/y placement in the grid\n        let x = (i % columns) * cellWidth,\n            y = Math.floor(i / columns) * cellHeight;\n\n        //Use the `makeSprite` function supplied in the constructor\n        //to make a sprite for the grid cell\n        let sprite = makeSprite();\n\n        //Add the sprite to the `container`\n        container.addChild(sprite);\n\n        //Should the sprite be centered in the cell?\n\n        //No, it shouldn't be centered\n        if (!centerCell) {\n          sprite.x = x + xOffset;\n          sprite.y = y + yOffset;\n        }\n\n        //Yes, it should be centered\n        else {\n          sprite.x \n            = x + (cellWidth / 2) \n            - (sprite.width / 2) + xOffset;\n          sprite.y \n            = y + (cellHeight / 2) \n            - (sprite.width / 2) + yOffset;\n        }\n\n        //Run any optional extra code. This calls the\n        //`extra` function supplied by the constructor\n        if (extra) extra(sprite);\n      }\n    };\n\n    //Run the `createGrid` method\n    createGrid();\n\n    //Return the `container` group back to the main program\n    return container;\n  }\n\n\n  /* Groups */\n\n  //Group sprites into a container\n  group(...sprites) {\n    let container = new this.Container();\n    sprites.forEach(sprite => {\n      container.addChild(sprite);\n    });\n    return container;\n  }\n\n  //Use the `batch` method to create a ParticleContainer\n  batch(size = 15000, options = {rotation: true, alpha: true, scale: true, uvs: true}) {\n    let batch = new this.ParticleContainer(size, options);\n    return batch;\n  }\n\n  //`remove` is a global convenience method that will\n  //remove any sprite, or an argument list of sprites, from its parent.\n  remove(...spritesToRemove) {\n\n    //Remove sprites that's aren't in an array\n    if (!(sprites[0] instanceof Array)) {\n      if (sprites.length > 1) {\n        sprites.forEach(sprite  => {\n          sprite.parent.removeChild(sprite);\n        });\n      } else {\n        sprites[0].parent.removeChild(sprites[0]);\n      }\n    }\n\n    //Remove sprites in an array of sprites\n    else {\n      let spritesArray = sprites[0];\n      if (spritesArray.length > 0) {\n        for (let i = spritesArray.length - 1; i >= 0; i--) {\n          let sprite = spritesArray[i];\n          sprite.parent.removeChild(sprite);\n          spritesArray.splice(spritesArray.indexOf(sprite), 1);\n        }\n      }\n    }\n  }\n  \n}\n\n\n\n"]}